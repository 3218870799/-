# 内存飙升

1：内存飙升问题，一次mysql占用内存极具飙升排查：

解决方案记录：

https://blog.51cto.com/u_15127586/2809954

怀疑是InnoDB缓冲池不足，默认128M，修改为4G发现，实际使用也远远超过了这个值；

```sql
set global innodb_buffer_pool_size = 4 227 858 432;
SELECT @@innodb_buffer_pool_size/1024/1024/1024; #字节转为G
```



glibc的内存管理器自身缺陷导致。  简言之，就是调用glibc申请的内存使用完毕后，归还给OS时没有被正常回收，而变成了碎片，随着碎片的不断增长，就能看到mysqld进程占用的内存不断上升。这时，可以调用函数主动回收释放这些碎片。

```txt
[root@mysql#] gdb --batch --pid `pidof mysqld` --ex 'call malloc_trim(0)'
 PID USER      PR  NI    VIRT    RES    SHR  S  %CPU %MEM     TIME+ COMMAND
45305 mysql     20   0   28.4g    5.2g   8288 S  2.7  17.0  64:56.82 mysqld
```

这就像是在InnoDB表中产生太多碎片后，主动执行OPTIMIZE TABLE重建表的做法。

官方对于内存的解释：https://dev.mysql.com/doc/refman/8.0/en/memory-use.html



总结一下出现磁盘IO占用过高的原因：

突然大批量变更库中数据，需要执行大量写入操作，如主从数据同步时就会出现这个问题。

MySQL处理的整体并发过高，磁盘I/O频率跟不上，比如是机械硬盘材质，读写速率过慢。

内存中的BufferPool缓冲池过小，大量读写操作需要落入磁盘处理，导致磁盘利用率过高。

频繁创建和销毁临时表，导致内存无法存储临时表数据，因而转到磁盘存储，导致磁盘飙升。

执行某些SQL时从磁盘加载海量数据，如超12张表的联查，并每张表数据较大，最终导致IO打满。

日志刷盘频率过高，其实这条是①、②的附带情况，毕竟日志的刷盘频率，跟整体并发直接挂钩。




# 死锁

MySQL内部其实会默认开启死锁检测算法，当运行期间出现死锁问题时，会主动介入并解除死锁，但要记住：**虽然数据库能够主动介入解除死锁问题，但这种方法治标不治本**

从业务上解决死锁问题，首先咱们得先定准定位到产生死锁的SQL语句，对于这点需要在MySQL内部会有一个日志，来记录着它自身捕获到的死锁，可以通过如下命令查看：

```sql
SHOW ENGINE INNODB STATUS\G; ## 查看InnoDB存储引擎的运行状态日志。
```

当出现死锁时，MySQL会将死锁对应的信息记录到该日志中，但这个日志会记录着InnoDB运行期间的所有状态日志，因此输入之后，要先找到LATEST DETECTED DEADLOCK这块区域的日志：



还有一种情况也会导致报死锁，但其实不是死锁，就是Mysql服务器磁盘空间不足的时候；



# CPU飙高

- 先找到CPU过高的服务器。
- 然后在其中定位到具体的进程。
- 再定位到进程中具体的线程。
- 再查看线程正在执行的代码逻辑。
- 最后从代码层面着手优化掉即可。

```shell
## 查看进程CPU利用率
top
## 查看进程中CPU占用率高的线程
top -Hp 76661
## 上边得到了操作系统层面的线程ID，找到OS线程与Mysql线程的对应关系，performance_schema库里有详细信息
-- 先连接MySQL数据库
mysql -uroot -p
Enter password: ***
 
-- 进入 performance_schema 库
use performance_schema;
 
-- 查询 threads 表（竖排输出）
SELECT * FROM threads\G;
```

但这种方式只能看到正在执行的SQL语句，无法查询到最近执行过的语句，所以这种方式仅适用于：线上SQL还在继续跑的情况，如果SQL已经执行结果，其实CPU的占用率也会下降，这类偶发性的CPU占用过高也无需排查，我们要优化的是那些一直导致CPU过高的SQL语句。

常见原因就是：慢SQL过多或者QPS过大



如：Mysql 占用 CPU100%，如何处理？

mysql CPU 使用已达到接近 400%（因为是四核，所以会有超过 100%的情况）

在服务器上执行 mysql -u root -p 之后，输入 show full processlist; 可以看到正在执行的语句。

但是从数据库设计方面来说，该做的索引都已经做了，SQL 语句似乎没有优化的空间。

直接执行此条 SQL，发现速度很慢，需要 1-6 秒的时间（跟 mysql 正在并发执行的查询有关，如果没有并发的，需要 1 秒多）。如果把排序依据改为一个，则查询时间可以缩短至 0.01 秒（most_top）或者 0.001 秒（posttime）。

优化：

首先是缩减查询范围







# 客户端连接异常

客户端连接异常也是一种较为常见的故障，这里有可能是因为多方面原因导致的，如下：

数据库总体的现有连接数，超出了MySQL中的最大连接数，此时再出现新连接时会出异常。

客户端数据库连接池与MySQL版本不匹配，或超时时间过小，也可能导致出现连接中断。

MySQL、Java程序所部署的机器不位于同一个网段，两台机器之间网络存在通信故障。

部署MySQL的机器资源被耗尽，如CPU、硬盘过高，导致MySQL没有资源分配给新连接。





# 慢查询



问题1：SQL执行慢的原因有哪些？如何进行SQL优化？

一、导致SQL执行慢的原因

1、硬件问题。如网络速度慢，内存不足，I/O吞吐量小，磁盘空间满了等。

2、没有索引或者索引失效。（一般在互联网公司，DBA会在半夜把表锁了，重新建立一遍索引，因为当你删除某个数据的时候，索引的树结构就不完整了。所以互联网公司的数据做的是假删除，一是为了做数据分析,二是为了不破坏索引 ）

3、数据过多（分库分表）

4、服务器调优及各个参数设置（调整my.cnf）

二、分析原因时，一定要找切入点

1、先观察，开启慢查询日志，设置相应的阈值（比如超过3秒就是慢SQL），在生产环境跑上个一天过后，看看哪些SQL比较慢。

2、Explain和慢SQL分析。比如SQL语句写的烂，索引没有或失效，关联查询太多（有时候是设计缺陷或者不得以的需求）等等。

3、Show Profile是比Explain更近一步的执行细节，可以查询到执行每一个SQL都干了什么事，这些事分别花了多少秒。

4、找DBA或者运维对MySQL进行服务器的参数调优。
解析：
(1)、explain出来的各种item的意义

id:每个被独立执行的操作的标志，表示对象被操作的顺序。一般来说， id 值大，先被执行；如果 id 值相同，则顺序从上到下。
select_type：查询中每个 select 子句的类型。
table:名字，被操作的对象名称，通常的表名(或者别名)，但是也有其他格式。
partitions:匹配的分区信息。
type:join 类型。
possible_keys：列出可能会用到的索引。
key:实际用到的索引。
key_len:用到的索引键的平均长度，单位为字节。
ref:表示本行被操作的对象的参照对象，可能是一个常量用 const 表示，也可能是其他表的
key 指向的对象，比如说驱动表的连接列。
rows:估计每次需要扫描的行数。
filtered:rows*filtered/100 表示该步骤最后得到的行数(估计值)。
extra:重要的补充信息。

(2)、profile的意义以及使用场景

Profile 用来分析 sql 性能的消耗分布情况。当用 explain 无法解决慢 SQL 的时候，需要用profile 来对 sql 进行更细致的分析，找出 sql 所花的时间大部分消耗在哪个部分，确认 sql的性能瓶颈。

(3)、explain 中的索引问题

Explain 结果中，一般来说，要看到尽量用 index(type 为 const、 ref 等， key 列有值)，避免使用全表扫描(type 显式为 ALL)。比如说有 where 条件且选择性不错的列，需要建立索引。
被驱动表的连接列，也需要建立索引。被驱动表的连接列也可能会跟 where 条件列一起建立联合索引。当有排序或者 group by 的需求时，也可以考虑建立索引来达到直接排序和汇总的需求。



问题二：SQL调优的几种方式：

**一：创建索引**

尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引

一个表的索引数最好不要超过6个

避免在索引上进行计算

**二：使用预编译查询**

程序中通常是根据用户的输入来动态执行SQL，这时应该尽量使用参数化SQL,这样不仅可以避免SQL注入漏洞攻击，最重要数据库会对这些参数化SQL进行预编译

**三：调整where连接顺序**

DBMS一般采用自下而上的顺序解析where字句，根据这个原理表连接最好写在其他where条件之前，那些可以过滤掉最大数量记录。

**四：多条SQL压缩到一条SQL**

**五：用where替换having字段**

因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前刷选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数 的过滤，除此之外，应该将条件写在where字句中。

**六：使用表的别名**

当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减 少哪些友列名歧义引起的语法错误。

**七：用union all 替换union**

**八：使用临时表暂存中间结果**

化SQL语句的重要方法就是采用临时表暂存中间结果，但是，临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。
但是也得避免频繁创建和删除临时表，以减少系统表资源的消耗。

九：**避免使用游标**

尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。

**十：用varchar/nvarchar代替char/nchar**

尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null 不占用空间。



#  sql 注入

sql 注入：某些 sql 语句的参数没有进行合理校检，参数中可能有危害数据库的一些语句，导致语句出错。

使用预编译语句的支持

一条语句可能会反复执行，或许每次执行只有个别语句不同。

使用占位符替代，一次编译，多次运行。

mysql 使用 PrepareStatement