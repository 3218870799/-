参考项目：[algorithmPractice](https://github.com/3218870799/algorithmPractice)

本笔记的每一个代码都有在上述项目的项目代码以及可运行测试类

# 1：数组

## 1.1：easy

**LeetCode118：杨辉三角**

给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。

在杨辉三角中，每个数是它左上方和右上方的数的和。

示例:

输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]

```java
package com.leetcode.array.easy;

import java.beans.IntrospectionException;
import java.lang.reflect.Array;
import java.util.*;

public class YanghuiTriangle118 {
    public static void main(String[] args) {
        int n = 5;
        //结果返回二维数组形式
        int[][] result2 = generate2(5);
        //lambda表达式遍历输出
        Arrays.stream(result2).forEach(arr->{
            Arrays.stream(arr).filter(i->i!=0).forEach( i ->System.out.print(i));
            System.out.println();
        });
        List<List<Integer>> result = generate(5);
    }

    /**
     * 解决：先给第一列全部赋值为1
     * 然后遍历二位数组，从第二行第二个开始，每一个等于上一行位置的加上上一行前一列位置的和
     * @param n
     * @return
     */
    public static int[][] generate2(int n) {
        int [][] result = new int[n][n];
        if (n<0){
            return result;
        }
        for (int j = 0; j < n; j++) {
            result[j][0] = 1;
        }
        for (int i = 1; i < n; i++) {
            for (int j = 1; j < n; j++) {
                result[i][j] =  result[i-1][j-1] + result[i-1][j];
            }
        }
        return result;
    }

    /**
     * 返回List<list<Integer>>
     * 两个List指针分别指向上一行和当前行
     * 第一行初始为1
     * 从第二行开始遍历
     * 当前行第一个为1，中间为currentList.add( last.get(j)+last.get(j-1));最后一个为1
     *
     * @param numRows
     * @return
     */
    public static List<List<Integer>> generate(int numRows) {
        if (numRows <= 0){
            return new ArrayList<List<Integer>>();
        }
        List<List<Integer>> result = new  ArrayList<List<Integer>>();
        List<Integer> last = new ArrayList<Integer>();
        last.add(1);
        result.add(last);
        for(int i=1; i< numRows;i++){
            List<Integer> currentList =  new ArrayList<Integer>();
            currentList.add(1);
            for (int j=1;j< i;j++){
                currentList.add( last.get(j)+last.get(j-1));
            }
            currentList.add(1);
            last = currentList;
            result.add(currentList);
        }
        return result;
    }

}

```



牛客网：

**数组左边最大值减右边最大值的差最大**



先遍历一遍数组，先求出全局最大值MAX

1）MAX被划分到左边，让右部分最大值尽量小，则只留最后一个，因为最后一个怎么划分都存在，故最后一个一定是差值最大的

2）MAX被划分到右边，则同理，划分到0的位置



**找出在一个数组中出现次数超过一半的数** 

思路一：遍历数组放入Map中，去的数组长度，遍历Map取得value值大于数组长度一半的值



思路二：

数组中有一个数字出现的次数超过了数组长度的一半。如果把这个数组『排序』，那么排序之后位于数组中间的数字一定就是那个出现次数超过数组长度一半的数字。

那么就变成找中间的这个数，快速排序的一个partition过程就是将



思路三：

数组中有一个数字出现的次数超过数组长度的一半，也就是说**它出现的次数比其他所有数字出现次数的和还要多**。

- 当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1；
- 如果下一个数字和我们之前保存的数字不同，则次数减1。
- 如果次数为零，我们需要保存下一个数字，并把次数设为1

我们要找的数字出现的次数比其他所有数字出现的次数之和还要多，那么要找的数字肯定是最后一次把次数设为1时对应的数字。

```java
public class MoreThanHalfNum {
    public static void main(String[] args) {
        int[] a = {1,5,2,2,3,4,2,2};
        int resutl = getMoreThanHalfNum(a);
    }

    private static Integer getMoreThanHalfNum(int[] array) {
        if (array == null)
            return null;
        Integer number = null;
        int count = 0;
        Integer resultInteger = null;
        for (int i = 0; i < array.length; i++) {
            if (number == null) {
                number = array[i];
                count++;
            } else {
                if (array[i] != number)
                    if (count == 0) {
                        number = array[i];
                        count = 1;
                    } else
                        count--;
                else
                    count++;
            }
            if (count == 1)
                resultInteger = number;
        }
        return resultInteger;

    }
}
```





## 1.2：medium

525：连续数组

给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组的长度。

示例 1:

输入: [0,1]
输出: 2
说明: [0, 1] 是具有相同数量0和1的最长连续子数组，长度为2
示例 2:

输入: [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组，长度为2。


注意: 给定的二进制数组的长度不会超过50000。

思路：

```
* 将0变成-1
* 使用hashtable，将和作为key，位置作为value，
* 如果遍历时和已经存在，说明从value到该位置的和为0，则result = 该位置index - value，判断哪个result最长
```

![image-20201130223253065](media/image-20201130223253065.png)

```java
private static int findMaxLength(int[] nums) {
    if(nums.length<=1) return 0;
    HashMap<Integer,Integer> pos = new HashMap<>();
    int sum = 0;
    int ans = 0;
    for (int i = 0; i < nums.length; i++) {
        sum += nums[i]==1?1:-1;
        //如果和为0，则也是其中一种结果
        if(sum==0){
            ans=i+1;
        }else if(pos.containsKey(sum)){
            //如果和已经存在，则取以前结果 和现在位置差最大的一个
            ans = Math.max(ans,i-pos.get(sum));
        }else{
            //如果没有，就放到hashMap里
            pos.put(sum,i);
        }
    }
    return ans;
}
```

//使用Array进行加速



## 1.3：Hard

315：计算右侧小于当前元素的个数



给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。

 

示例：

输入：nums = [5,2,6,1]
输出：[2,1,1,0] 
解释：
5 的右侧有 2 个更小的元素 (2 和 1)
2 的右侧仅有 1 个更小的元素 (1)
6 的右侧有 1 个更小的元素 (1)
1 的右侧有 0 个更小的元素


提示：

0 <= nums.length <= 10^5
-10^4 <= nums[i] <= 10^4

思路：

```txt
1：暴力的两层for循环，但是数太多太大

```





## 







# 

https://cuijiahua.com/blog/2018/02/basis_67.html

https://www.nowcoder.com/ta/coding-interviews

# 2：字符串

## 2.1Easy

牛客网：

题目描述

输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。

输入描述:

```
输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。
```

示例1

输入

```
"ab"
```

返回值

```
["ab","ba"]
```

**思路**

假设输入为a、b、c
那么其实排序的总数：
fun（a，b，c）=a（fun（b，c））+ b（fun（a，c））{即将a和b交换}+ c（fun（b，a））{ 即将a和c交换 }
fun（b，c） = b+fun（c）+c（fun（b））{即将b与c交换}
fun（c）=1

题目中说可能存在重复字符，因此交换时需要判断交换的字符是否相等，如果相等就没必要换了

```java
import java.util.*;

public class StringSort {

    public static void main(String[] args) {
        String str = "abcd";
        ArrayList<String> result = Permutation(str);
        result.stream().forEach(System.out::println);
    }

    public static ArrayList<String> Permutation(String str) {
        StringBuilder strBuilder = new StringBuilder(str);
        ArrayList<String> result = PermutationHelp(strBuilder);
        return result;
    }
    public static ArrayList<String> PermutationHelp(StringBuilder str){
        ArrayList<String> result = new  ArrayList<String>();
        if(str.length() == 1){
            result.add(str.toString());
        }else{
            for(int i = 0; i < str.length(); i++){
                //可能有重复字符，先判定该字符是否已经交换过排序过
                if(i == 0 || str.charAt(i) != str.charAt(0)){
                    char temp = str.charAt(i);
                    str.setCharAt(i, str.charAt(0));
                    str.setCharAt(0, temp);
                    ArrayList<String> newResult = PermutationHelp(new StringBuilder(str.substring(1)));
                    for(int j =0; j < newResult.size(); j++)
                        result.add(str.substring(0,1)+newResult.get(j));
                    //用完还是要放回去的
                    temp = str.charAt(0);
                    str.setCharAt(0, str.charAt(i));
                    str.setCharAt(i, temp);
                }
            }
            //需要在做一个排序操作
            Collections.sort(result);
        }
        return result;
    }
}

```





# 3：链表

## 3.1 Easy

**160. 相交链表**

编写一个程序，找到两个单链表相交的起始节点。

如下面的两个链表**：**

![img](media/160_statement.png)

在节点 c1 开始相交。

思路：

1. 如果两个链表相交，则交点比在较短的链表的其中一个节点上

2. 遍历两个链表计算两个链表的长度，相减计算长度的差值

3. 较长的链表先走差值的长度

4. 同时遍历两个链表，比较两个链表的值，相等则相交

   

```java
package com.xqc.LinkedList.Easy;

/**
 * @ClassName GetIntersectionNode160
 * @Author Administrator
 * @Date 2020/12/16/016 18:02
 * @Description TODO
 */
public class GetIntersectionNode160 {
    public class ListNode {
      int val;
      ListNode next;
      ListNode(int x) {
          val = x;
          next = null;
      }
    }
    public static void main(String[] args) {

    }
    public static ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int lenA = 0;
        int lenB = 0;
        ListNode listA = headA;
        ListNode listB = headB;

        while (listA != null) {
            listA = listA.next;
            lenA++;
        }
        while (listB != null) {
            listB = listB.next;
            lenB++;
        }

        int diff;
        if(lenA > lenB) {
            diff = lenA - lenB;
            while (diff > 0) {
                diff--;
                headA = headA.next;
            }
        } else {
            diff = lenB - lenA;
            while (diff > 0) {
                diff--;
                headB = headB.next;

            }
        }

        while (headA != null && headB != null) {
            if (headA == headB) {
                return headA;
            }
            headA = headA.next;
            headB = headB.next;
        }

        return null;
    }

}
```





# 4：二叉树

## easy

二叉树找一条和最大的路径

思路：

首先一条路径遍历到叶子节点的时候，两个叶子节点的根节点相同，也就是到其根节点的路径上节点的val的和是一样的，此时那个节点的值大，那么最大路劲就会在哪个路径上。这就是递归的最初思想，之后扩展到左右子树

即：

递归求出左边最大值，递归求出右边最大值，出口为节点为null返回0

最大值等于 Max(左边最大值，右边最大值) + 根的值

```java
public class TreeMaxPath {

    public static int max = Integer.MIN_VALUE;  // 始终保持最大的和

    // root到叶节点的最大路径的和
    public static int solution(TreeNode root) {
        if(root == null) {
            return 0;
        }
        int left = solution(root.left);
        int right = solution(root.right);
        max = Math.max(max, left + right + root.val);// 更新max值
        return Math.max(left, right) + root.val;
    }


    public static void main(String[] args) {
        // Test case
        TreeNode node1 = new TreeNode(1);
        TreeNode node2 = new TreeNode(2);
        TreeNode node3 = new TreeNode(3);
        TreeNode node4 = new TreeNode(4);
        TreeNode node5 = new TreeNode(5);

        node1.left = node2;
        node1.right = node3;
        node2.left = node4;
        node2.right = node5;

        solution(node1);
        System.out.println("max = " + max);
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int val){
        this.val = val;
    }
}
```



# 4：图



## medium

LeetCode133：克隆图

一个无向图，如何深copy

给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。

图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。

class Node {
    public int val;
    public List<Node> neighbors;
}

思路：

采用深度优先递归克隆节点，克隆节点邻居时，遍历克隆邻居并深度递归克隆邻居节点



```java
public class cloneGraph133 {
    class Solution{
        //定义一个hashMap，key代表节点的值，value代表该节点，可以用于记录是否已经遍历过该节点
        Map<Integer,Node> map = new HashMap<>();
        public Node cloneGraph(Node node){
            //判空
            if (node==null)
                return null;
            //如果不为空，深度优先克隆图
            return dfsClone(node);
        }
        private Node dfsClone(Node node){
            if(node==null) return null;
            //如果该节点已经遍历过，已经存放于map中
            if (map.containsKey(node.val)){
                return map.get(node.val);
            }
            //如果没有遍历过，新建一个节点
            Node newNode = new Node(node.val,new ArrayList<>());
            //然后将该节点放入到map中
            map.put(node.val,newNode);
            for (Node neighbor:node.neighbors) {
                //然后深度优先克隆他的邻居节点
                newNode.neighbors.add(dfsClone(neighbor));
            }
            return newNode;
        }
    }
    class Node {
        public int val;
        public List<Node> neighbors;
        public Node() {
            val = 0;
            neighbors = new ArrayList<Node>();
        }
        public Node(int _val) {
            val = _val;
            neighbors = new ArrayList<Node>();
        }
        public Node(int _val, ArrayList<Node> _neighbors) {
            val = _val;
            neighbors = _neighbors;
        }
    }
}
```

