参考项目：[algorithmPractice](https://github.com/3218870799/algorithmPractice)

本笔记的每一个代码都有在上述项目的项目代码以及可运行测试类

# 1：数组

## 1.1：easy

**LeetCode118：杨辉三角**

给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。

在杨辉三角中，每个数是它左上方和右上方的数的和。

示例:

输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]

```java
package com.leetcode.array.easy;

import java.beans.IntrospectionException;
import java.lang.reflect.Array;
import java.util.*;

public class YanghuiTriangle118 {
    public static void main(String[] args) {
        int n = 5;
        //结果返回二维数组形式
        int[][] result2 = generate2(5);
        //lambda表达式遍历输出
        Arrays.stream(result2).forEach(arr->{
            Arrays.stream(arr).filter(i->i!=0).forEach( i ->System.out.print(i));
            System.out.println();
        });
        List<List<Integer>> result = generate(5);
    }

    /**
     * 解决：先给第一列全部赋值为1
     * 然后遍历二位数组，从第二行第二个开始，每一个等于上一行位置的加上上一行前一列位置的和
     * @param n
     * @return
     */
    public static int[][] generate2(int n) {
        int [][] result = new int[n][n];
        if (n<0){
            return result;
        }
        for (int j = 0; j < n; j++) {
            result[j][0] = 1;
        }
        for (int i = 1; i < n; i++) {
            for (int j = 1; j < n; j++) {
                result[i][j] =  result[i-1][j-1] + result[i-1][j];
            }
        }
        return result;
    }

    /**
     * 返回List<list<Integer>>
     * 两个List指针分别指向上一行和当前行
     * 第一行初始为1
     * 从第二行开始遍历
     * 当前行第一个为1，中间为currentList.add( last.get(j)+last.get(j-1));最后一个为1
     *
     * @param numRows
     * @return
     */
    public static List<List<Integer>> generate(int numRows) {
        if (numRows <= 0){
            return new ArrayList<List<Integer>>();
        }
        List<List<Integer>> result = new  ArrayList<List<Integer>>();
        List<Integer> last = new ArrayList<Integer>();
        last.add(1);
        result.add(last);
        for(int i=1; i< numRows;i++){
            List<Integer> currentList =  new ArrayList<Integer>();
            currentList.add(1);
            for (int j=1;j< i;j++){
                currentList.add( last.get(j)+last.get(j-1));
            }
            currentList.add(1);
            last = currentList;
            result.add(currentList);
        }
        return result;
    }

}

```



牛客网：

**数组左边最大值减右边最大值的差最大**



先遍历一遍数组，先求出全局最大值MAX

1）MAX被划分到左边，让右部分最大值尽量小，则只留最后一个，因为最后一个怎么划分都存在，故最后一个一定是差值最大的

2）MAX被划分到右边，则同理，划分到0的位置



**找出在一个数组中出现次数超过一半的数** 

思路一：遍历数组放入Map中，去的数组长度，遍历Map取得value值大于数组长度一半的值









思路二：

数组中有一个数字出现的次数超过了数组长度的一半。如果把这个数组『排序』，那么排序之后位于数组中间的数字一定就是那个出现次数超过数组长度一半的数字。

那么就变成找中间的这个数，快速排序的一个partition过程就是将



思路三：

数组中有一个数字出现的次数超过数组长度的一半，也就是说**它出现的次数比其他所有数字出现次数的和还要多**。

- 当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1；
- 如果下一个数字和我们之前保存的数字不同，则次数减1。
- 如果次数为零，我们需要保存下一个数字，并把次数设为1

我们要找的数字出现的次数比其他所有数字出现的次数之和还要多，那么要找的数字肯定是最后一次把次数设为1时对应的数字。

```java
public class MoreThanHalfNum {
    public static void main(String[] args) {
        int[] a = {1,5,2,2,3,4,2,2};
        int resutl = getMoreThanHalfNum(a);
    }

    private static Integer getMoreThanHalfNum(int[] array) {
        if (array == null)
            return null;
        Integer number = null;
        int count = 0;
        Integer resultInteger = null;
        for (int i = 0; i < array.length; i++) {
            if (number == null) {
                number = array[i];
                count++;
            } else {
                if (array[i] != number)
                    if (count == 0) {
                        number = array[i];
                        count = 1;
                    } else
                        count--;
                else
                    count++;
            }
            if (count == 1)
                resultInteger = number;
        }
        return resultInteger;

    }
}
```



Leetcode 121. 买卖股票的最佳时机

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

示例 1:

```
输入: [7,1,5,3,6,4]
输出: 5
```

解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。

```
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
```

示例 2:

```
输入: [7,6,4,3,1]
输出: 0
```

解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

题解

纪录两个状态, 一个是最大利润, 另一个是遍历过的子序列的最小值。知道之前的最小值我们就可以算出当前天可能的最大利润是多少

```
class Solution {
    public int maxProfit(int[] prices) {
        // 7,1,5,3,6,4
        int maxProfit = 0;
        int minNum = Integer.MAX_VALUE;
        for (int i = 0; i < prices.length; i++) {
            if (Integer.MAX_VALUE != minNum && prices[i] - minNum > maxProfit) {
                maxProfit = prices[i] - minNum;
            }

            if (prices[i] < minNum) {
                minNum = prices[i];
            }
        }
        return maxProfit;
    }
}
```

Leetcode 122. 买卖股票的最佳时机 II

这次改成股票可以买卖多次, 但是你必须要在出售股票之前把持有的股票卖掉。
示例 1:

```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

示例 2:

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

示例 3:

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

题解

由于可以无限次买入和卖出。我们都知道炒股想挣钱当然是低价买入高价抛出，那么这里我们只需要从第二天开始，如果当前价格比之前价格高，则把差值加入利润中，因为我们可以昨天买入，今日卖出，若明日价更高的话，还可以今日买入，明日再抛出。以此类推，遍历完整个数组后即可求得最大利润。

```
class Solution {
    public int maxProfit(int[] prices) {
        // 7,1,5,3,6,4
        int maxProfit = 0;
        for (int i = 0; i < prices.length; i++) {
            if (i != 0 && prices[i] - prices[i-1] > 0) {
                maxProfit += prices[i] - prices[i-1];
            }
        }
        return maxProfit;
    }
}
```

## 1.2：medium

525：连续数组

给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组的长度。

示例 1:

输入: [0,1]
输出: 2
说明: [0, 1] 是具有相同数量0和1的最长连续子数组，长度为2
示例 2:

输入: [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组，长度为2。


注意: 给定的二进制数组的长度不会超过50000。

思路：

```
* 将0变成-1
* 使用hashtable，将和作为key，位置作为value，
* 如果遍历时和已经存在，说明从value到该位置的和为0，则result = 该位置index - value，判断哪个result最长
```

![image-20201130223253065](media/image-20201130223253065.png)

```java
private static int findMaxLength(int[] nums) {
    if(nums.length<=1) return 0;
    HashMap<Integer,Integer> pos = new HashMap<>();
    int sum = 0;
    int ans = 0;
    for (int i = 0; i < nums.length; i++) {
        sum += nums[i]==1?1:-1;
        //如果和为0，则也是其中一种结果
        if(sum==0){
            ans=i+1;
        }else if(pos.containsKey(sum)){
            //如果和已经存在，则取以前结果 和现在位置差最大的一个
            ans = Math.max(ans,i-pos.get(sum));
        }else{
            //如果没有，就放到hashMap里
            pos.put(sum,i);
        }
    }
    return ans;
}
```

//使用Array进行加速



**300：最长上升子序列**



思路一：动态规划

记录数组中每一个数的最长上升子序列

该数的最长上升子序列  =   前一个比它小的 +1 

代码思路

一开始一个外部循环

​			内部循环从第一位截止到当前位置

​						如果前面的比当前位置小，则长度 + 1，选取最长的进行赋值

更新全局的最长长度



思路二：二分搜索

[10,9,2,5,7,101,18]

10

9

2

2,5

2,5,7

2,5,7,101

2,5,7,18

对于每一个新来的数，看他在最长上升子序列中的那个部分，把对应部分加入

只有放在最后的时候长度才会++

如果放在开始和中间，只有中间数更小，后边才能更新更长的

复杂度nlogn

```java
	/**
	 * 最长上升子序列
	 * [10,9,2,5,7,101,18]则最长上升子序列为2，3, 7, 18
	 * 使用动态规划
	 * @param nums
	 * @return
	 */
	public static int lengthOfLIS(int[] nums){
		
		int n = nums.length;
		//截止到某一个index的最长上升子序列
		int[] dp = new int[n];
		int maxLen = 0;
		
		for(int i=0;i<n;i++){
			//一个数也是上升子序列
			int len =1;
			
			for(int j=0;j<i;j++){
				//
				if(nums[j]<nums[i]){
					len=Math.max(len, dp[j]+1);
				}
			}
			//截止到i的最长长度
			dp[i]=len;
			if(dp[i]>maxLen){
				maxLen=dp[i];
			}
		}
		return maxLen;
		
	}
	/**
	 * 最长上升子序列
	 * 如果新加入的对比于原本的中间，则替换，如果在最后，则长度加一
	 * @param nums
	 * @return
	 */
	public static int lengthOfLISFunction2(int[] nums){
		int n = nums.length;
		int[] dp = new int[n];
		int len =0;
		for (int num : nums) {
			//二分收索判断num在dp中的什么地方，即下标多少，范围是0到len
			int index = Arrays.binarySearch(dp, 0, len ,num);
			//<0则没有出现过，取到应该放的地方
			//pos = 
			if(index<0){
				index = -(index+1);
			}
			//如果在中间就直接更新为这个数
			dp[index] = num;
			//这个应该插入的位置在最后
			if(index==len){
				//长度要加一
				len++;
			}	
		}
		return len;
	}
```



## 1.3：Hard

315：计算右侧小于当前元素的个数



给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。

 

示例：

输入：nums = [5,2,6,1]
输出：[2,1,1,0] 
解释：
5 的右侧有 2 个更小的元素 (2 和 1)
2 的右侧仅有 1 个更小的元素 (1)
6 的右侧有 1 个更小的元素 (1)
1 的右侧有 0 个更小的元素


提示：

0 <= nums.length <= 10^5
-10^4 <= nums[i] <= 10^4

思路：

```txt
1：暴力的两层for循环，但是数太多太大

```





## 







# 

https://cuijiahua.com/blog/2018/02/basis_67.html

https://www.nowcoder.com/ta/coding-interviews

# 2：字符串

## 2.1Easy

牛客网：

题目描述

输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。

输入描述:

```
输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。
```

示例1

输入

```
"ab"
```

返回值

```
["ab","ba"]
```

**思路**

假设输入为a、b、c
那么其实排序的总数：
fun（a，b，c）=a（fun（b，c））+ b（fun（a，c））{即将a和b交换}+ c（fun（b，a））{ 即将a和c交换 }
fun（b，c） = b+fun（c）+c（fun（b））{即将b与c交换}
fun（c）=1

题目中说可能存在重复字符，因此交换时需要判断交换的字符是否相等，如果相等就没必要换了

```java
import java.util.*;

public class StringSort {

    public static void main(String[] args) {
        String str = "abcd";
        ArrayList<String> result = Permutation(str);
        result.stream().forEach(System.out::println);
    }

    public static ArrayList<String> Permutation(String str) {
        StringBuilder strBuilder = new StringBuilder(str);
        ArrayList<String> result = PermutationHelp(strBuilder);
        return result;
    }
    public static ArrayList<String> PermutationHelp(StringBuilder str){
        ArrayList<String> result = new  ArrayList<String>();
        if(str.length() == 1){
            result.add(str.toString());
        }else{
            for(int i = 0; i < str.length(); i++){
                //可能有重复字符，先判定该字符是否已经交换过排序过
                if(i == 0 || str.charAt(i) != str.charAt(0)){
                    char temp = str.charAt(i);
                    str.setCharAt(i, str.charAt(0));
                    str.setCharAt(0, temp);
                    ArrayList<String> newResult = PermutationHelp(new StringBuilder(str.substring(1)));
                    for(int j =0; j < newResult.size(); j++)
                        result.add(str.substring(0,1)+newResult.get(j));
                    //用完还是要放回去的
                    temp = str.charAt(0);
                    str.setCharAt(0, str.charAt(i));
                    str.setCharAt(i, temp);
                }
            }
            //需要在做一个排序操作
            Collections.sort(result);
        }
        return result;
    }
}

```

**最长公共子串**

给定两个字符串，求他们之间最长饿相同子字符串的长度

使用dp\[i][j]来表示第一个串的前i位和第二个串的前j位中的最长公共子串，

计算某个二维矩阵的值的时候顺便计算出来当前最长的公共子串的长度，即某个二维矩阵元素的值由record[i][j]=1演变为record[i][j]=1 +record\[i-1][j-1]，这样就避免了后续查找对角线长度的操作了。

![img](media/785056-20190801104941268-279704884.png)



```java
public int getLCS(String s, String t) {
        if (s == null || t == null) {
            return 0;
        }
        int result = 0;
        int sLength = s.length();
        int tLength = t.length();
        int[][] dp = new int[sLength][tLength];
        for (int i = 0; i < sLength; i++) {
            for (int k = 0; k < tLength; k++) {
                if (s.charAt(i) == t.charAt(k)) {
                    if (i == 0 || k == 0) {
                        dp[i][k] = 1;
                    } else {
                        dp[i][k] = dp[i - 1][k - 1] + 1;
                    }
                    result = Math.max(dp[i][k], result);
                } else {
                    dp[i][k] = 0;
                }
            }
        }
        return result;
    }
```





**最长公共子序列**

公共子串与公共子序列不同，公共子序列不要求连续，公共子串必须是连续的。

如

A = “helloworld”

B = “loop”

则最长公共子串是lo

最长公共子序列是loo

* 规划二维数组，比较字符相同，如果相同则把i-1.j-1的值加1
* 如果不同，则把两个对角的最大的值复制过来

```java
	public static int LCS(String a,String b){
		int m = a.length();
		int n = b.length();
		int[][] dp = new int[m+1][n+1];

		for(int i=0;i<m;i++){
			for(int j=0;j<n;j++){
				char c1 = a.charAt(i);
				char c2 = b.charAt(j);
				if(c1==c2){
					dp[i+1][j+1]=dp[i][j]+1;
				}else {
					dp[i+1][j+1]=Math.max(dp[i+1][j], dp[i][j+1]);
				}
			}
		}
		
		return dp[m][n];
	}
```



最长上升子序列

参考前面数组Easy中最长上升子序列





# 3：链表

## 3.1 Easy

**160. 相交链表**

编写一个程序，找到两个单链表相交的起始节点。

如下面的两个链表**：**

![img](media/160_statement.png)

在节点 c1 开始相交。

思路：

1. 如果两个链表相交，则交点比在较短的链表的其中一个节点上

2. 遍历两个链表计算两个链表的长度，相减计算长度的差值

3. 较长的链表先走差值的长度

4. 同时遍历两个链表，比较两个链表的值，相等则相交

   

```java
package com.xqc.LinkedList.Easy;

/**
 * @ClassName GetIntersectionNode160
 * @Author Administrator
 * @Date 2020/12/16/016 18:02
 * @Description TODO
 */
public class GetIntersectionNode160 {
    public class ListNode {
      int val;
      ListNode next;
      ListNode(int x) {
          val = x;
          next = null;
      }
    }
    public static void main(String[] args) {

    }
    public static ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int lenA = 0;
        int lenB = 0;
        ListNode listA = headA;
        ListNode listB = headB;

        while (listA != null) {
            listA = listA.next;
            lenA++;
        }
        while (listB != null) {
            listB = listB.next;
            lenB++;
        }

        int diff;
        if(lenA > lenB) {
            diff = lenA - lenB;
            while (diff > 0) {
                diff--;
                headA = headA.next;
            }
        } else {
            diff = lenB - lenA;
            while (diff > 0) {
                diff--;
                headB = headB.next;

            }
        }

        while (headA != null && headB != null) {
            if (headA == headB) {
                return headA;
            }
            headA = headA.next;
            headB = headB.next;
        }

        return null;
    }

}
```





# 4：二叉树

## easy

二叉树找一条和最大的路径

思路：

首先一条路径遍历到叶子节点的时候，两个叶子节点的根节点相同，也就是到其根节点的路径上节点的val的和是一样的，此时那个节点的值大，那么最大路劲就会在哪个路径上。这就是递归的最初思想，之后扩展到左右子树

即：

递归求出左边最大值，递归求出右边最大值，出口为节点为null返回0

最大值等于 Max(左边最大值，右边最大值) + 根的值

```java
public class TreeMaxPath {

    public static int max = Integer.MIN_VALUE;  // 始终保持最大的和

    // root到叶节点的最大路径的和
    public static int solution(TreeNode root) {
        if(root == null) {
            return 0;
        }
        int left = solution(root.left);
        int right = solution(root.right);
        max = Math.max(max, left + right + root.val);// 更新max值
        return Math.max(left, right) + root.val;
    }


    public static void main(String[] args) {
        // Test case
        TreeNode node1 = new TreeNode(1);
        TreeNode node2 = new TreeNode(2);
        TreeNode node3 = new TreeNode(3);
        TreeNode node4 = new TreeNode(4);
        TreeNode node5 = new TreeNode(5);

        node1.left = node2;
        node1.right = node3;
        node2.left = node4;
        node2.right = node5;

        solution(node1);
        System.out.println("max = " + max);
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int val){
        this.val = val;
    }
}
```

**LeetCode104：二叉树转链表**

给定一个二叉树，原地将它展开为链表。

例如，给定二叉树

```
    1
   / \
  2   5
 / \   \
3   4   6
```

将其展开为：

```
1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```



思路：

转换的时候递归的时候记住是先转换右子树，再转换左子树。

右子树转换完之后链表的头结点在哪里。注意没有新定义一个next指针，而是直接将right 当做next指针,那么Left指针我们赋值成null就可以了。

```java
class Solution {
    private TreeNode prev = null;

    public void flatten(TreeNode root) {
        if (root == null)  return;
        flatten(root.right); // 先转换右子树
        flatten(root.left); 
        root.right = prev;  // 右子树指向链表的头
        root.left = null; // 把左子树置空
        prev = root; // 当前结点为链表头
    }
}
```

非递归实现

```java
class Solution {
    public void flatten(TreeNode root) {
        if (root == null) return;
        Stack<TreeNode> stack = new Stack<TreeNode>();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode current = stack.pop();
            if (current.right != null) stack.push(current.right);
            if (current.left != null) stack.push(current.left);
            if (!stack.isEmpty()) current.right = stack.peek();
            current.left = null;
        }
    }
}
```





**树中两个节点的最低公共祖先**

 输入两个二叉搜索树的结点，求两个结点的最低公共祖先，所谓的最低公共祖先是指距离两个节点最近的共同祖先。

解题思路：

- 1.二叉搜索树具有一个很好的特点。**以当前结点为根节点的左边结点的值都是小于根节点的值，右边结点的值都大于根节点的值。**
- 2.根据这个特点，如果给的两个节点的值都`小于`根节点，那么它们的最低公共祖先就一定在它左子树。
- 3.如果给的两个节点的值都`大于`根节点，那么它们的最低公共祖先就一定在它右子树。
- 4.如果`一个结点的值大于根节点的值`，`一个结点的值小于根节点的值`，那么这个根节点就是它的最低公共祖先。

若只是一颗二叉树

- 如果一个结点为根，另一个结点无论在什么地方它们的最低公共祖先一定为根结点。
- 如果一个结点在左树，另一个结点在右树，那么它的最低公共祖先一定是根节点。
- 如果两个结点都在左树，以子问题在左树查找。
- 如果两个结点都在右树，以子问题在右树查找。

```java
public class Solution {  
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {  
        //发现目标节点则通过返回值标记该子树发现了某个目标结点  
        if(root == null || root == p || root == q) return root;  
        //查看左子树中是否有目标结点，没有为null  
        TreeNode left = lowestCommonAncestor(root.left, p, q);  
        //查看右子树是否有目标节点，没有为null  
        TreeNode right = lowestCommonAncestor(root.right, p, q);  
        //都不为空，说明做右子树都有目标结点，则公共祖先就是本身  
        if(left!=null&&right!=null) return root;  
        //如果发现了目标节点，则继续向上标记为该目标节点  
        return left == null ? right : left;  
    }  
}
```





# 4：图



## medium

LeetCode133：克隆图

一个无向图，如何深copy

给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。

图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。

class Node {
    public int val;
    public List<Node> neighbors;
}

思路：

采用深度优先递归克隆节点，克隆节点邻居时，遍历克隆邻居并深度递归克隆邻居节点



```java
public class cloneGraph133 {
    class Solution{
        //定义一个hashMap，key代表节点的值，value代表该节点，可以用于记录是否已经遍历过该节点
        Map<Integer,Node> map = new HashMap<>();
        public Node cloneGraph(Node node){
            //判空
            if (node==null)
                return null;
            //如果不为空，深度优先克隆图
            return dfsClone(node);
        }
        private Node dfsClone(Node node){
            if(node==null) return null;
            //如果该节点已经遍历过，已经存放于map中
            if (map.containsKey(node.val)){
                return map.get(node.val);
            }
            //如果没有遍历过，新建一个节点
            Node newNode = new Node(node.val,new ArrayList<>());
            //然后将该节点放入到map中
            map.put(node.val,newNode);
            for (Node neighbor:node.neighbors) {
                //然后深度优先克隆他的邻居节点
                newNode.neighbors.add(dfsClone(neighbor));
            }
            return newNode;
        }
    }
    class Node {
        public int val;
        public List<Node> neighbors;
        public Node() {
            val = 0;
            neighbors = new ArrayList<Node>();
        }
        public Node(int _val) {
            val = _val;
            neighbors = new ArrayList<Node>();
        }
        public Node(int _val, ArrayList<Node> _neighbors) {
            val = _val;
            neighbors = _neighbors;
        }
    }
}
```

