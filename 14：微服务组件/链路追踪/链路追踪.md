跟踪请求在分布式系统中的流转路径与状态，从而协助开发人员能够进行故障诊断、容量评估、性能瓶颈分析等工作。 我们可以看到典型的链路轨迹追踪例子：比如用户通过手机做了一个下单动作，这个请求会通过移动端来到网关，再到应用层，比如说有交易、下单、支付等等一系列的应用，然后中间也会穿插到去调用云基础设施，这样用户的行为轨迹是能够被清晰还原出来的。

应用分级：

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/tMJtfgIIibWJ7QENrvArSiaFJEFXtnOhPn8ibMtAvR2lnDddjGib2fFX85e8XWx7PFOKBvicIiahbu7L40HnG19q4MvQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

最基础级就是通过调用链来还原单次请求的轨迹状态，这是最基本的应用。

再往上，可以对链路数据去做预聚合或后聚合统计的分析，去看整个链路在概率分布上的一些信息，比如说整个服务维度的监控数据，上下游整体的依赖，这是第二级

第三等级，就是除了调用链数据本身具备的这些链路数据之外，还可以更进一步发挥关联性作用，把一些间接的业务数据，包括容器或者 JVM 的一些指标信息或者是一些变更的日志事件，也能够通过调用链紧密的关联在一起，形成多维数据关联和分析，最终来实现我们根因定位的能力。

再往后有点像自动驾驶，有了这么多数据，能不能够自动发现其中一些问题？可以结合领域专家经验和恰当的算法，来实现整个诊断流程自动化或者半自动化。 

最后一步就是诊断问题的最终目标--保障系统稳定。能不能够把问题诊断和系统恢复两个事关联在一起？从而实现整个系统的故障自愈，进一步提升稳定性。这个就需要与管控系统去融合。目前开源 Tracing 系统大概是在 L1 到 L3 的等级。

完成一个链路的追踪，一般需要完成以下几步：

第一步，完成整个应用的全链条全链路的上下文透传，从端侧设备开始到后端，然后网关或者是应用等等。这里面的话其实就涉及到异构语言的数据打通和前后端的透传。

比如说前端或者说整个透传的格式，或需要采用统一格式，比如说我们可以选择统一的 Jaeger 格式来透传来我们的协议头，我们前端接入比如说我们可以采用 CDN 或者 NPM 两种的这种低代码的接入方式，可以支持外部小程序等各种各样的场景，我们后端如果是 JAVA 的话，就会优先推进使用 ARMS Agent 来完成无侵入的这样的一个代码的接入。并且在 JAVA 的应用上面，我们会提供很多比如说边缘诊断、无损统计的这样一些高阶的能力，非 JAVA 的话就可以比方说我们可以通过开源的 Agent 和 SDK 来接入，然后并且上报到我们的 Endpoint 上面，当然 ARMS 也在去兼容 SkyWalking 的协议格式。

第二步，完成了客户端的这种全链路埋点之后，我们数据要上报上来，就会面临存储和计算的成本，最好的方式就是说能够按需去存储数据，只存有价值的数据来降低成本。



第三步就是数据存储下来之后，肯定还要通过查询再发挥它的价值。这时候遇到的问题就是数据之间的格式不统一，能不能把所有的指标数据转化成一个比方说 Prometheus的这种格式，这样指标数据格式相对统一了，Traces 能不能支持这种 OpenTelemetry 的格式，然后是日志支持 Loki 这种方案。

第 4 步，释放价值。灵活自定义用户档案。当然还可以按照用户的使用习惯，也可以做一些自定义的控制台。同样道理，告警也是一样的，我们可以去用 PromQL 做一个灵活的自定义的告警，同时我们也支持把数据路由到用户名下的一些存储，比如说 SLS 下面，这样你想去做一些二次的批量的分析

