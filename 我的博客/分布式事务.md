# 一：分布式数据一致性

CAP 定理，BASE 理论，请参考：

[CAP 定理与 BASE 理论](https://github.com/3218870799/-Note/blob/main/40%EF%BC%9A%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.md#cap%E5%AE%9A%E7%90%86)

- TX 协议：应用或者应用服务器与事务管理器的接口。
- XA 协议：全局事务管理器与资源管理器的接口。XA 是由 X/Open 组织提出的分布式事务规范。该规范主要定义了全局事务管理器和局部资源管理器之间的接口。主流的数据库产品都实现了 XA 接口。XA 接口是一个双向的系统接口，在事务管理器以及多个资源管理器之间作为通信桥梁。之所以需要 XA 是因为在分布式系统中从理论上讲两台机器是无法达到一致性状态的，因此引入一个单点进行协调。由全局事务管理器管理和协调的事务可以跨越多个资源和进程。全局事务管理器一般使用 XA 二阶段协议与数据库进行交互。

# 二：柔性事务

柔性事务中的服务模式：

1. 可查询操作：服务操作具有全局唯一的标识，操作唯一的确定的时间。
2. 幂等操作：重复调用多次产生的业务结果与调用一次产生的结果相同。一是通过业务操作实现幂等性，二是系统缓存所有请求与处理的结果，最后是检测到重复请求之后，自动返回之前的处理结果。
3. TCC（补偿事务）操作：Try 阶段，尝试执行业务，完成所有业务的检查，实现一致性；预留必须的业务资源，实现准隔离性。Confirm 阶段：真正的去执行业务，不做任何检查，仅适用 Try 阶段预留的业务资源，Confirm 操作还要满足幂等性。Cancel 阶段：取消执行业务，释放 Try 阶段预留的业务资源，Cancel 操作要满足幂等性。TCC 与 2PC(两阶段提交)协议的区别：TCC 位于业务服务层而不是资源层，TCC 没有单独准备阶段，Try 操作兼备资源操作与准备的能力，TCC 中 Try 操作可以灵活的选择业务资源，锁定粒度。TCC 的开发成本比 2PC 高。实际上 TCC 也属于两阶段操作，但是 TCC 不等同于 2PC 操作。
4. 可补偿操作：Do 阶段：真正的执行业务处理，业务处理结果外部可见。Compensate 阶段：抵消或者部分撤销正向业务操作的业务结果，补偿操作满足幂等性。约束：补偿操作在业务上可行，由于业务执行结果未隔离或者补偿不完整带来的风险与成本可控。实际上，TCC 的 Confirm 和 Cancel 操作可以看做是补偿操作。

## 解决方案

# 二：两段式提交

两阶段提交协议是协调所有分布式原子事务参与者，并决定提交或取消（回滚）的分布式算法。

在两阶段提交协议中，系统一般包含两类机器（或节点）：一类为协调者（coordinator），通常一个系统中只有一个；另一类为事务参与者（participants，cohorts 或 workers），一般包含多个，在数据存储系统中可以理解为数据副本的个数。协议中假设每个节点都会记录写前日志（write-ahead log）并持久性存储，即使节点发生故障日志也不会丢失。协议中同时假设节点不会发生永久性故障而且任意两个节点都可以互相通信。

**两个阶段的执行**

1.请求阶段（commit-request phase，或称表决阶段，voting phase）
在请求阶段，协调者将通知事务参与者准备提交或取消事务，然后进入表决过程。
在表决过程中，参与者将告知协调者自己的决策：同意（事务参与者本地作业执行成功）或取消（本地作业执行故障）。

2.提交阶段（commit phase）
在该阶段，协调者将基于第一个阶段的投票结果进行决策：提交或取消。
当且仅当所有的参与者同意提交事务协调者才通知所有的参与者提交事务，否则协调者将通知所有的参与者取消事务。
参与者在接收到协调者发来的消息后将执行响应的操作。

**两阶段提交的缺点**

1.同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。
当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。

2.单点故障。由于协调者的重要性，一旦协调者发生故障。
参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）

3.数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送 commit 请求之后，发生了局部网络异常或者在发送 commit 请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了 commit 请求。
而在这部分参与者接到 commit 请求之后就会执行 commit 操作。但是其他部分未接到 commit 请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。‘

**两阶段提交无法解决的问题**

当协调者出错，同时参与者也出错时，两阶段无法保证事务执行的完整性。
考虑协调者再发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。
那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。

# 三：三段式提交

三阶段提交协议在协调者和参与者中都引入超时机制，并且把两阶段提交协议的第一个阶段拆分成了两步：询问，然后再锁资源，最后真正提交。

![image-20210218211753546](media/image-20210218211753546.png)

**三个阶段的执行**
1.CanCommit 阶段
3PC 的 CanCommit 阶段其实和 2PC 的准备阶段很像。
协调者向参与者发送 commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应。

2.PreCommit 阶段
Coordinator 根据 Cohort 的反应情况来决定是否可以继续事务的 PreCommit 操作。
根据响应情况，有以下两种可能。
A.假如 Coordinator 从所有的 Cohort 获得的反馈都是 Yes 响应，那么就会进行事务的预执行：
发送预提交请求。Coordinator 向 Cohort 发送 PreCommit 请求，并进入 Prepared 阶段。
事务预提交。Cohort 接收到 PreCommit 请求后，会执行事务操作，并将 undo 和 redo 信息记录到事务日志中。
响应反馈。如果 Cohort 成功的执行了事务操作，则返回 ACK 响应，同时开始等待最终指令。

B.假如有任何一个 Cohort 向 Coordinator 发送了 No 响应，或者等待超时之后，Coordinator 都没有接到 Cohort 的响应，那么就中断事务：
发送中断请求。Coordinator 向所有 Cohort 发送 abort 请求。
中断事务。Cohort 收到来自 Coordinator 的 abort 请求之后（或超时之后，仍未收到 Cohort 的请求），执行事务的中断。

3.DoCommit 阶段

该阶段进行真正的事务提交，也可以分为以下两种情况:

执行提交

A.发送提交请求。Coordinator 接收到 Cohort 发送的 ACK 响应，那么他将从预提交状态进入到提交状态。并向所有 Cohort 发送 doCommit 请求。
B.事务提交。Cohort 接收到 doCommit 请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。
C.响应反馈。事务提交完之后，向 Coordinator 发送 ACK 响应。
D.完成事务。Coordinator 接收到所有 Cohort 的 ACK 响应之后，完成事务。

中断事务

Coordinator 没有接收到 Cohort 发送的 ACK 响应（可能是接受者发送的不是 ACK 响应，也可能响应超时），那么就会执行中断事务。

**三阶段提交协议的缺点**

如果进入 PreCommit 后，Coordinator 发出的是 abort 请求，假设只有一个 Cohort 收到并进行了 abort 操作，
而其他对于系统状态未知的 Cohort 会根据 3PC 选择继续 Commit，此时系统状态发生不一致性。

柔性事务，执行 SQL 时实现三个接口，代码侵入性较强，不选择

事务协调器，LCN，维护全局事务的状态，

# Seata

参考：[14:SpringCloudAlibaba # Seata](https://github.com/3218870799/-Note/blob/main/14.1SpringCloudAlibaba/SpringCloudAlibaba.md#seata)
事务管理器，资源管理器

整个 Seata，

依赖，写两个配置文件

两段式提交会先去看

seata 是立即提交，减少锁住的时间，如果第二个事务出错了，自动调用 seata 的语句对第一个事务进行回滚。
