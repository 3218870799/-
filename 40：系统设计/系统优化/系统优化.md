# 优化报告

1：描述现象，确定优化的必要性；

2：性能分析，确定性能瓶颈究竟发生在那个部分

3：策略决策，指定策略，是的投入产出比最大化

4：验证收益，持续监控优化后的系统，拿到指标提升的证据

5：产出优化报告

# 优化策略

性能优化说简单也简单，说复杂也复杂，有时候，只需加个索引就能解决问题。有时候，需要做代码重构。有时候，需要增加缓存。有时候，需要引入一些中间件，比如mq。有时候，需要需要分库分表。有时候，需要拆分服务。等等。。。

常见方法如下

## 增加资源

1：垂直扩展

存储：

SSD比机械硬盘更快；

PMEM持久化内存：比传统内存更大，快；

DDR：双倍数据流，上升沿和下降沿都可以进行读写；



计算：

GPU：并行的高密度浮点数计算

FPGA：

TPU/NPU：专用机器学习训练



网络：

SmartNIC智能网卡：降低CPU计算负载，处理网络数据包处理的瓶颈；

DPU：

RDMA：减少网络协议传输的性能损耗；替换传统RPC的底层协议；



2：水平扩展



## 处理方式

1：并行化

对任务粒度的拆解，区分任务之间的独立和依赖性；

```txt
1)异步/非阻塞：
2)并发：
3)DAG将任务拆解组织成DAG调用图，并行处理不同任务，拓扑排序
```

2：批处理

减少操作次数提高吞吐

3：流处理



## 快速路径

1：资源复用

```txt
1:资源隔离：对频繁竞争的资源进行隔离，减少资源征用造成的耗时
	A：减少锁的粒度
2：业务缓存：精排缓存；一致性缓存，机器本身缓存；数据压缩
3：资源共享，减少资源的重复获取和计算
4：资源池化
5：资源压缩
6：资源虚拟化
```

2：计算剪支

```txt
1：大json解析：
2：近似解
3：采样计算：兜底，计数，日志，打点
```

3：逻辑重构

```txt
1：删除无效逻辑
2：精简关键路径
```



## 算法优化

1：数据结构

时间轮；



2：快速算法



3：高效操作

```txt
指针传递
零拷贝
减少系统调用
优化耗时操作
```



## 依赖优化

对依赖的优化

1：升级/降级

```txt
升级语言版本，升级指令集，升级内核版本
```

2：调参/自适应

```txt
内核参数调优
业务参数调优
依赖组件参数
```

3：替换/定制



## 数据压缩

举一个视频网站的例子，如果不对视频做任何压缩编码，因为带宽有限，巨大的数据量在网络传输的耗时会比编码压缩的耗时多得多。

我们在代码中通常用的是无损压缩，比如下面这些场景:

- HTTP协议中Accept-Encoding添加Gzip/deflate，服务端对接受压缩的文本（JS/CSS/HTML）请求做压缩，大部分图片格式本身已经是压缩的无需压缩；
- HTTP2协议的头部HPACK压缩；
- JS/CSS文件的混淆和压缩（Uglify/Minify）；
- 一些RPC协议和消息队列传输的消息中，采用二进制编码和压缩（Gzip、Snappy、LZ4等等）；
- 缓存服务存过大的数据，通常也会事先压缩一下再存，取的时候解压；
- 一些大文件的存储，或者不常用的历史数据存储，采用更高压缩比的算法存储；
- JVM的对象指针压缩，JVM在32G以下的堆内存情况下默认开启“UseCompressedOops”，用4个byte就可以表示一个对象的指针，这也是JVM尽量不要把堆内存设置到32G以上的原因；
- MongoDB的二进制存储的BSON相对于纯文本的JSON也是一种压缩，或者说更紧凑的编码。但更紧凑的编码也意味着更差的可读性，这一点也是需要取舍的。纯文本的JSON比二进制编码要更占存储空间但却是REST API的主流，因为数据交换的场景下的可读性是非常重要的。

信息论告诉我们，无损压缩的极限是信息熵。进一步减小体积只能以损失部分信息为代价，也就是有损压缩。

那么，有损压缩有哪些应用呢？

- 预览和缩略图，低速网络下视频降帧、降清晰度，都是对信息的有损压缩；
- 音视频等多媒体数据的采样和编码大多是有损的，比如MP3是利用傅里叶变换，有损地存储音频文件；jpeg等图片编码也是有损的。虽然有像WAV/PCM这类无损的音频编码方式，但多媒体数据的采样本身就是有损的，相当于只截取了真实世界的极小一部分数据；
- 散列化，比如K-V存储时Key过长，先对Key执行一次“傻”系列（SHA-1、SHA-256）哈希算法变成固定长度的短Key。另外，散列化在文件和数据验证（MD5、CRC、HMAC）场景用的也非常多，无需耗费大量算力对比完整的数据。

## 增加缓存

DNS缓存；

数据库缓存；

池化技术：



## 预热

视频或直播类网站，在播放前先缓冲一小段时间，就是预取数据。有的在播放时不仅预取这一条数据，甚至还会预测下一个要看的其他内容，提前把数据取到本地；

服务端同样也会用一些预热机制，一方面热点数据预取到内存提前形成多级缓存；另一方面也是对运行环境的预热，载入CPU高速缓存、热点函数JIT编译成机器码等等；

热点资源提前预分配到各个实例，比如：秒杀、售票的库存性质的数据；分布式唯一ID等等

HTTP/2 Server Push，在浏览器请求某个资源时，服务器顺带把其他相关的资源一起推回去，HTML/JS/CSS几乎同时到达浏览器端，相当于浏览器被动预取了资源；

一些客户端软件会用常驻进程的形式，提前预取数据或执行一些代码，这样可以极大提高第一次使用的打开速度；

## 异步处理

非业务核心操作，放到后台多线程处理，或者MQ；但是要解决数据丢失问题；

削峰填谷：







## 优化索引与SQL

请参考《MYSQL》篇

# 2：远程调用优化

方式1：能保存下来肯定先保存

方式2：必须调用选择并行调用远程接口

![图片](https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5hq0iaKg80FgbtoMf7wY5zmvUC155A7eBbGB76ho3DX2KE2vptrOxuOXfibsibcwL9zJac4CI9w8YS5w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

```java
    //并行调用远程接口
    public UserInfo getUserInfo(Long id){
        UserInfo userInfo = new UserInfo();
        //使用自定义线程池并行调用远程接口
        CompletableFuture userFuture = CompletableFuture.supplyAsync(() -> {
            getRemoterUserAndFill(id,userInfo);
            return Boolean.TRUE;
        },executor);
        CompletableFuture bonusFuture = CompletableFuture.supplyAsync(() -> {
            getRemoterBonusAndFill(id,userInfo);
            return Boolean.TRUE;
        },executor);
        CompletableFuture growthFuture = CompletableFuture.supplyAsync(() -> {
            getRemoterGrowthAndFill(id,userInfo);
            return Boolean.TRUE;
        },executor);
       
        CompletableFuture.allOf(userFuture,bonusFuture,growthFuture).join();
        userFuture.get();
        bonusFuture.get();
        growthFuture.get();
        return userInfo;
    }

```



# 4：大事务

1. 少用@Transactional注解
2. 将查询(select)方法放到事务外
3. 事务中避免远程调用
4. 事务中避免一次性处理太多数据
5. 有些功能可以非事务执行
6. 有些功能可以异步处理

# 5：锁粒度

在某些业务场景中，为了防止多个线程并发修改某个共享数据，造成数据异常。

为了解决并发场景下，多个线程同时修改数据，造成数据不一致的情况。通常情况下，我们会：`加锁`。

但如果锁加得不好，导致锁的粒度太粗，也会非常影响接口性能。

redis分布式锁，尽可能锁更小的粒度；

```java
public void doSave(String path,String fileUrl) {
   if(this.tryLock()) {
      mkdir(path);
   }
   uploadFile(fileUrl);
   sendMessage(fileUrl);
}

private boolean tryLock() {
    try {
    String result = jedis.set(lockKey, requestId, "NX", "PX", expireTime);
    if ("OK".equals(result)) {
      return true;
    }
  } finally{
      unlock(lockKey,requestId);
  }  
  return false;
}
```



# 生产 JVM 优化

参考 JVM 篇

# 数据库优化

参考数据库篇

# 服务器优化

Tomcat 参考 Tomcat 篇

# MVC 优化

8 秒原则：用户在访问 WEb 网页是，如果时间超过 8 秒就会刚到不耐烦；

加载过程的优化常用的方法：

1：减少资源大小：压缩 HTML，CSS，JS，图片等大小图片大小优化可使用 iconfont 或 SVG 代替。webp 优于 jpg，PNG8 优于 gif。也可以使用熊猫压缩工具压缩图片资源大小，在不图片失真的情况下，也可以将图片大小压缩至少一半。

2：减少 Http 请求数：

3：使用缓存机制：

4：首屏快速加载：

5：预加载：

6：避免多重定向

# ORM 优化

# 网络优化

# 前端优化

## SEO 搜索引擎优化

指为了增加网页在搜索引擎自然搜索结果中的收录数量以及提升排序位置而坐的优化行为；

从宏观角度来说，SEO 三条最重要的规律：原创的内容，高质量的外部链接和持之以恒的适度优化；

1：突出重要内容：合理的 titlee，description 和 keyWords；

2：语义化的 HTML，复合 W3C 标准

3：利用布局，重要的内容放到前面

4：重要内容不要放到 JS 中，爬虫不会爬取 JS 的内容；

5：尽量少使用 iframe 框架；

6：为图片加上 ALT 属性

7：

# 业务优化

最有效

# 产品优化

功能性：

可靠性：成熟性，容错性，易操作性

用户体验：

性能：

可维护性：

易安装性：

# 代码质量

1：严格遵循编程规范;

小就是美、简单就是美;

始终在使用前检测指针变量的有效性，判断nullptr;

指针和标量类型使用值传递，其它都使用指针和引用传递;

多用只读常量、局部变量，少用全局变量、静态变量;识别无符号数和有符号数的应用场景并正确选择数据类型;

2：代码性能

3：易错代码

访问错误：数组索引访问越界；指针对象访问越界；访问空指针对象；访问无效指针对象；迭代器访问越界

内存泄露：

参数错误：本地代理，空指针，强制转换

堆栈溢出：递归调用，循环调用，消息循环，大对象参数，大对象变量

转换错误：有符号类型和无符号类型；

内存碎片：小内存快重复分配释放导致的内存碎片，导致内存不足



