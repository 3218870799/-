# 优化报告

1：描述现象，确定优化的必要性；

2：性能分析，确定性能瓶颈究竟发生在那个部分

3：策略决策，指定策略，是的投入产出比最大化

4：验证收益，持续监控优化后的系统，拿到指标提升的证据

5：产出优化报告

# 优化策略

## 增加资源

1：垂直扩展

存储：

SSD比机械硬盘更快；

PMEM持久化内存：比传统内存更大，快；

DDR：双倍数据流，上升沿和下降沿都可以进行读写；



计算：

GPU：并行的高密度浮点数计算

FPGA：

TPU/NPU：专用机器学习训练



网络：

SmartNIC智能网卡：降低CPU计算负载，处理网络数据包处理的瓶颈；

DPU：

RDMA：减少网络协议传输的性能损耗；替换传统RPC的底层协议；



2：水平扩展



## 处理方式

1：并行化

对任务粒度的拆解，区分任务之间的独立和依赖性；

```txt
1)异步/非阻塞：
2)并发：
3)DAG将任务拆解组织成DAG调用图，并行处理不同任务，拓扑排序
```

2：批处理

减少操作次数提高吞吐

3：流处理



## 快速路径

1：资源复用

```txt
1:资源隔离：对频繁竞争的资源进行隔离，减少资源征用造成的耗时
	A：减少锁的粒度
2：业务缓存：精排缓存；一致性缓存，机器本身缓存；数据压缩
3：资源共享，减少资源的重复获取和计算
4：资源池化
5：资源压缩
6：资源虚拟化
```

2：计算剪支

```txt
1：大json解析：
2：近似解
3：采样计算：兜底，计数，日志，打点
```

3：逻辑重构

```txt
1：删除无效逻辑
2：精简关键路径
```



## 算法优化

1：数据结构

时间轮；



2：快速算法



3：高效操作

```txt
指针传递
零拷贝
减少系统调用
优化耗时操作
```



## 依赖优化

对依赖的优化

1：升级/降级

```txt
升级语言版本，升级指令集，升级内核版本
```

2：调参/自适应

```txt
内核参数调优
业务参数调优
依赖组件参数
```

3：替换/定制







性能优化说简单也简单，说复杂也复杂，有时候，只需加个索引就能解决问题。有时候，需要做代码重构。有时候，需要增加缓存。有时候，需要引入一些中间件，比如mq。有时候，需要需要分库分表。有时候，需要拆分服务。等等。。。

常见方法如下

# 1：优化索引与SQL

请参考《MYSQL》篇

# 2：远程调用优化

方式1：能保存下来肯定先保存

方式2：必须调用选择并行调用远程接口

![图片](https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5hq0iaKg80FgbtoMf7wY5zmvUC155A7eBbGB76ho3DX2KE2vptrOxuOXfibsibcwL9zJac4CI9w8YS5w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

```java
    //并行调用远程接口
    public UserInfo getUserInfo(Long id){
        UserInfo userInfo = new UserInfo();
        //使用自定义线程池并行调用远程接口
        CompletableFuture userFuture = CompletableFuture.supplyAsync(() -> {
            getRemoterUserAndFill(id,userInfo);
            return Boolean.TRUE;
        },executor);
        CompletableFuture bonusFuture = CompletableFuture.supplyAsync(() -> {
            getRemoterBonusAndFill(id,userInfo);
            return Boolean.TRUE;
        },executor);
        CompletableFuture growthFuture = CompletableFuture.supplyAsync(() -> {
            getRemoterGrowthAndFill(id,userInfo);
            return Boolean.TRUE;
        },executor);
       
        CompletableFuture.allOf(userFuture,bonusFuture,growthFuture).join();
        userFuture.get();
        bonusFuture.get();
        growthFuture.get();
        return userInfo;
    }

```

# 3：异步处理

非业务核心操作，放到后台多线程处理，或者MQ；但是要解决数据丢失问题；

# 4：大事务

1. 少用@Transactional注解
2. 将查询(select)方法放到事务外
3. 事务中避免远程调用
4. 事务中避免一次性处理太多数据
5. 有些功能可以非事务执行
6. 有些功能可以异步处理

# 5：锁粒度

在某些业务场景中，为了防止多个线程并发修改某个共享数据，造成数据异常。

为了解决并发场景下，多个线程同时修改数据，造成数据不一致的情况。通常情况下，我们会：`加锁`。

但如果锁加得不好，导致锁的粒度太粗，也会非常影响接口性能。

redis分布式锁，尽可能锁更小的粒度；

```java
public void doSave(String path,String fileUrl) {
   if(this.tryLock()) {
      mkdir(path);
   }
   uploadFile(fileUrl);
   sendMessage(fileUrl);
}

private boolean tryLock() {
    try {
    String result = jedis.set(lockKey, requestId, "NX", "PX", expireTime);
    if ("OK".equals(result)) {
      return true;
    }
  } finally{
      unlock(lockKey,requestId);
  }  
  return false;
}
```



# 生产 JVM 优化

参考 JVM 篇

# 数据库优化

参考数据库篇

# 服务器优化

Tomcat 参考 Tomcat 篇

# MVC 优化

8 秒原则：用户在访问 WEb 网页是，如果时间超过 8 秒就会刚到不耐烦；

加载过程的优化常用的方法：

1：减少资源大小：压缩 HTML，CSS，JS，图片等大小图片大小优化可使用 iconfont 或 SVG 代替。webp 优于 jpg，PNG8 优于 gif。也可以使用熊猫压缩工具压缩图片资源大小，在不图片失真的情况下，也可以将图片大小压缩至少一半。

2：减少 Http 请求数：

3：使用缓存机制：

4：首屏快速加载：

5：预加载：

6：避免多重定向

# ORM 优化

# 网络优化

# 前端优化

## SEO 搜索引擎优化

指为了增加网页在搜索引擎自然搜索结果中的收录数量以及提升排序位置而坐的优化行为；

从宏观角度来说，SEO 三条最重要的规律：原创的内容，高质量的外部链接和持之以恒的适度优化；

1：突出重要内容：合理的 titlee，description 和 keyWords；

2：语义化的 HTML，复合 W3C 标准

3：利用布局，重要的内容放到前面

4：重要内容不要放到 JS 中，爬虫不会爬取 JS 的内容；

5：尽量少使用 iframe 框架；

6：为图片加上 ALT 属性

7：

# 业务优化

最有效

# 产品优化

功能性：

可靠性：成熟性，容错性，易操作性

用户体验：

性能：

可维护性：

易安装性：

# 代码质量

1：严格遵循编程规范;

小就是美、简单就是美;

始终在使用前检测指针变量的有效性，判断nullptr;

指针和标量类型使用值传递，其它都使用指针和引用传递;

多用只读常量、局部变量，少用全局变量、静态变量;识别无符号数和有符号数的应用场景并正确选择数据类型;

2：代码性能

3：易错代码

访问错误：数组索引访问越界；指针对象访问越界；访问空指针对象；访问无效指针对象；迭代器访问越界

内存泄露：

参数错误：本地代理，空指针，强制转换

堆栈溢出：递归调用，循环调用，消息循环，大对象参数，大对象变量

转换错误：有符号类型和无符号类型；

内存碎片：小内存快重复分配释放导致的内存碎片，导致内存不足



